generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URI")
}

model User {
  id             Int       @id @default(autoincrement())
  email          String    @unique
  name           String
  password       String?
  profilePicture String?
  type           UserType  @default(DEVELOPER)
  phoneNumber    String?   @unique
  countryCode    String?
  country        String?
  industry       String?
  role           Role?     @relation(fields: [roleId], references: [id])
  roleId         Int?
  isVerified     Boolean   @default(false)
  kycStatus      KycStatus @default(PENDING)
  earlybird      Boolean   @default(false)
  wallet         Float     @default(0)

  // Profile relationships
  developerProfile  DeveloperProfile?
  leadProfile       LeadProfile?
  githubIntegration GitHubIntegration?

  // Relationships
  ownedProjects         Project[]                 @relation("ProjectOwner")
  teamLeadProjects      Project[]                 @relation("TeamLead")
  participatingProjects ProjectCollaborator[]
  assignedIssues        Issue[]
  reportedIssues        Issue[]                   @relation("IssueReporter")
  conversations         ConversationParticipant[]
  createdConversations  Conversation[]
  messages              Message[]
  transactions          Transaction[]
  payments              Payment[]
  collaborationRequests CollaborationRequest[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Role {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  displayName String
  description String?
  isActive    Boolean @default(true)
  permissions Json
  users       User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("roles")
}

model Project {
  id              Int           @id @default(autoincrement())
  title           String
  slug            String        @unique
  description     String
  longDescription String?
  logoUrl         String?
  type            ProjectType   @default(NORMAL)
  status          ProjectStatus @default(PLANNED)
  state           ProjectState  @default(DRAFT)
  startDate       DateTime
  endDate         DateTime?
  budget          Float?

  // Owner and Team
  owner         User                  @relation("ProjectOwner", fields: [ownerId], references: [id])
  ownerId       Int
  teamLead      User?                 @relation("TeamLead", fields: [teamLeadId], references: [id])
  teamLeadId    Int?
  collaborators ProjectCollaborator[]

  // Technical
  stacks     ProjectStack[]
  issues     Issue[]
  repository GitHubRepository?

  // Milestones
  milestones Json
  tags       String[]

  // Product Association
  product   Product? @relation(fields: [productId], references: [id])
  productId Int?

  // Conversations
  conversations Conversation[]
  transactions  Transaction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("projects")
}

model Issue {
  id              Int             @id @default(autoincrement())
  title           String
  slug            String          @unique
  description     String?
  longDescription String?
  type            IssueType       @default(FEATURE)
  category        IssueCategory[]
  status          IssueStatus     @default(OPEN)
  priority        Priority        @default(MEDIUM)
  budget          Float?

  // Media
  onboardingVideoLink    String?
  onboardingVideoUrl     String?
  onboardingThumbnailUrl String?

  // Relationships
  project    Project @relation(fields: [projectId], references: [id])
  projectId  Int
  assignees  User[]
  reporter   User    @relation("IssueReporter", fields: [reporterId], references: [id])
  reporterId Int

  // Collaboration
  collaborationRequests CollaborationRequest[]
  requests              IssueRequest[]
  labels                String[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("issues")
}

model CollaborationRequest {
  id              Int                 @id @default(autoincrement())
  developer       User                @relation(fields: [developerId], references: [id])
  developerId     Int
  issue           Issue               @relation(fields: [issueId], references: [id])
  issueId         Int
  percentageShare Float
  taskDefinition  String?
  status          CollaborationStatus @default(PENDING)
  requestedAt     DateTime            @default(now())

  @@map("collaboration_requests")
}

model GitHubRepository {
  id            Int     @id @default(autoincrement())
  repoId        String  @unique
  name          String
  fullName      String
  url           String
  isPrivate     Boolean @default(false)
  description   String?
  language      String?
  defaultBranch String?

  // Project association
  project   Project? @relation(fields: [projectId], references: [id])
  projectId Int?     @unique

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  pushedAt  DateTime?

  @@map("github_repositories")
}

model Conversation {
  id           Int              @id @default(autoincrement())
  title        String
  name         String?
  type         ConversationType @default(PRIVATE)
  description  String?
  avatarUrl    String?
  isArchived   Boolean          @default(false)
  archivedAt   DateTime?
  messageCount Int              @default(0)

  // Relationships
  participants  ConversationParticipant[]
  messages      Message[]
  project       Project?                  @relation(fields: [projectId], references: [id])
  projectId     Int?
  createdBy     User?                     @relation(fields: [createdById], references: [id])
  createdById   Int?
  lastMessage   Message?                  @relation("LastMessage", fields: [lastMessageId], references: [id])
  lastMessageId Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("conversations")
}

model Message {
  id      Int         @id @default(autoincrement())
  content String
  type    MessageType @default(TEXT)

  // Relationships
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  conversationId Int
  sender         User         @relation(fields: [senderId], references: [id])
  senderId       Int
  replyTo        Message?     @relation("MessageReply", fields: [replyToId], references: [id])
  replyToId      Int?
  replies        Message[]    @relation("MessageReply")

  // Media
  attachments String[]

  // Status
  isEdited  Boolean   @default(false)
  editedAt  DateTime?
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  // Read tracking
  lastMessage      Conversation[]            @relation("LastMessage")
  participantReads ConversationParticipant[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("messages")
}

// Junction Tables and Supporting Models

model ProjectCollaborator {
  id        Int      @id @default(autoincrement())
  project   Project  @relation(fields: [projectId], references: [id])
  projectId Int
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  joinedAt  DateTime @default(now())

  @@unique([projectId, userId])
  @@map("project_collaborators")
}

model ConversationParticipant {
  id                Int               @id @default(autoincrement())
  conversation      Conversation      @relation(fields: [conversationId], references: [id])
  conversationId    Int
  user              User              @relation(fields: [userId], references: [id])
  userId            Int
  role              ParticipantRole   @default(MEMBER)
  joinedAt          DateTime          @default(now())
  leftAt            DateTime?
  lastReadMessage   Message?          @relation(fields: [lastReadMessageId], references: [id])
  lastReadMessageId Int?
  notifications     NotificationLevel @default(ALL)

  @@unique([conversationId, userId])
  @@map("conversation_participants")
}

model Transaction {
  id          Int               @id @default(autoincrement())
  user        User              @relation(fields: [userId], references: [id])
  userId      Int
  amount      Float
  type        TransactionType
  method      PaymentMethod
  status      TransactionStatus @default(PENDING)
  reference   String?
  description String?
  project     Project?          @relation(fields: [projectId], references: [id])
  projectId   Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("transactions")
}

// Supporting models

model Product {
  id       Int       @id @default(autoincrement())
  name     String
  projects Project[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("products")
}

model DeveloperProfile {
  id                  Int              @id @default(autoincrement())
  user                User             @relation(fields: [userId], references: [id])
  userId              Int              @unique
  bio                 String?
  experience          Int?
  experienceLevel     ExperienceLevel?
  availability        Availability?
  preferredWorkType   WorkType?
  hourlyRate          Float?
  stripeAccountId     String?
  stripeAccountStatus StripeStatus     @default(PENDING)
  skills              Skill[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("developer_profiles")
}

model LeadProfile {
  id               Int            @id @default(autoincrement())
  user             User           @relation(fields: [userId], references: [id])
  userId           Int            @unique
  title            String?
  location         String?
  preferredPayment PaymentMethod?
  specializations  Stack[]
  calendar         Calendar[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("lead_profiles")
}

model GitHubIntegration {
  id                   Int          @id @default(autoincrement())
  user                 User         @relation(fields: [userId], references: [id])
  userId               Int          @unique
  githubId             String?      @unique
  githubUsername       String?
  githubConnected      Boolean      @default(false)
  githubConnectedAt    DateTime?
  githubAccessToken    String?
  githubInstallationId String?
  githubLastFetch      DateTime?
  githubRepositories   GitHubRepo[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("github_integrations")
}

model GitHubRepo {
  id                  Int               @id @default(autoincrement())
  githubIntegration   GitHubIntegration @relation(fields: [githubIntegrationId], references: [id])
  githubIntegrationId Int
  repoId              String
  name                String

  @@map("github_repos")
}

model Skill {
  id                 Int              @id @default(autoincrement())
  developerProfile   DeveloperProfile @relation(fields: [developerProfileId], references: [id])
  developerProfileId Int
  name               String

  @@map("skills")
}

model Stack {
  id            Int         @id @default(autoincrement())
  leadProfile   LeadProfile @relation(fields: [leadProfileId], references: [id])
  leadProfileId Int
  name          String

  @@map("stacks")
}

model Calendar {
  id            Int         @id @default(autoincrement())
  leadProfile   LeadProfile @relation(fields: [leadProfileId], references: [id])
  leadProfileId Int
  date          DateTime

  @@map("calendars")
}

model ProjectStack {
  id        Int     @id @default(autoincrement())
  project   Project @relation(fields: [projectId], references: [id])
  projectId Int
  name      String

  @@map("project_stacks")
}

model IssueRequest {
  id      Int    @id @default(autoincrement())
  issue   Issue  @relation(fields: [issueId], references: [id])
  issueId Int
  content String

  @@map("issue_requests")
}

model Payment {
  id     Int   @id @default(autoincrement())
  user   User  @relation(fields: [userId], references: [id])
  userId Int
  amount Float

  @@map("payments")
}

// Enums
enum UserType {
  DEVELOPER
  STARTUP
  DESIGNER
  LEAD
  PROJECT_MANAGER
}

enum KycStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum ExperienceLevel {
  JUNIOR
  MID_LEVEL
  SENIOR
  LEAD
  ARCHITECT
}

enum Availability {
  FULL_TIME
  PART_TIME
  CONTRACT
  FREELANCE
  NOT_AVAILABLE
}

enum WorkType {
  REMOTE
  ON_SITE
  HYBRID
}

enum StripeStatus {
  PENDING
  ACTIVE
  RESTRICTED
  DISABLED
}

enum PaymentMethod {
  HOURLY
  DCM
  CREDIT_CARD
  BANK_TRANSFER
  CRYPTO
}

enum ProjectType {
  NORMAL
  URGENT
  FEATURED
  TRENDING
}

enum ProjectStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  ON_HOLD
}

enum ProjectState {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  APPROVED
  IN_PROGRESS
  COMPLETED
  REJECTED
}

enum IssueType {
  FEATURE
  BUG
}

enum IssueCategory {
  BACKEND
  FRONTEND
  APPLICATION
  AI
  DATA
  MACHINE_LEARNING
  DEVOPS
  SECURITY
  DATABASE
  QUALITY_ASSURANCE
  DOCUMENTATION
  SEO
}

enum IssueStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum CollaborationStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum ConversationType {
  PRIVATE
  GROUP
  PROJECT
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
}

enum CollaboratorStatus {
  ACTIVE
  INACTIVE
}

enum CollaboratorRole {
  MEMBER
  TEAM_LEAD
  ADMIN
}

enum ParticipantRole {
  ADMIN
  MODERATOR
  MEMBER
}

enum NotificationLevel {
  ALL
  MENTIONS
  MUTED
}

enum TransactionType {
  INCOME
  WITHDRAWAL
  TIP
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
}

// Better Auth Required Models
model BetterAuthUser {
  id String @id
  name String
  email String @unique
  emailVerified Boolean @default(false)
  image String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  sessions BetterAuthSession[]
  accounts BetterAuthAccount[]
  
  @@map("user")
}

model BetterAuthSession {
  id String @id
  expiresAt DateTime
  token String @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId String
  user BetterAuthUser @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("session")
}

model BetterAuthAccount {
  id String @id
  accountId String
  providerId String
  userId String
  user BetterAuthUser @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken String?
  refreshToken String?
  idToken String?
  accessTokenExpiresAt DateTime?
  refreshTokenExpiresAt DateTime?
  scope String?
  password String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("account")
}

model BetterAuthVerification {
  id String @id
  identifier String
  value String
  expiresAt DateTime
  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt
  
  @@map("verification")
}
